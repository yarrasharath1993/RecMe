#!/usr/bin/env npx tsx
/**
 * APPLY ACTOR CORRECTIONS
 * 
 * Parse and apply batch corrections from CSV/TSV files generated by the validator.
 * Supports operations: update, re-attribute, add, delete-duplicate
 * 
 * Based on Venkatesh (76 films) and Nani (31 films) correction workflows.
 * 
 * Usage:
 *   npx tsx scripts/apply-actor-corrections.ts --actor="Nani" --input="docs/nani-corrections.csv"
 *   npx tsx scripts/apply-actor-corrections.ts --actor="Venkatesh" --input="docs/venkatesh-fixes.tsv" --execute
 *   npx tsx scripts/apply-actor-corrections.ts --actor="Mahesh Babu" --input="docs/mahesh-corrections.csv" --dry-run
 * 
 * CSV Format:
 *   action,slug,field,value
 *   update,nani-2020,heroine,Nivetha Thomas
 *   re-attribute,alasyam-amrutham-2010,hero,Nikhil Siddharth
 *   delete,duplicate-entry-slug,,
 *   add,new-movie-2020,title_en,New Movie
 */

import { createClient, SupabaseClient } from '@supabase/supabase-js';
import * as dotenv from 'dotenv';
import * as fs from 'fs';
import chalk from 'chalk';
import * as path from 'path';

dotenv.config({ path: '.env.local' });

// ============================================================
// TYPES
// ============================================================

type CorrectionAction = 'update' | 're-attribute' | 'delete' | 'add' | 'clear';

interface Correction {
  action: CorrectionAction;
  slug: string;
  field?: string;
  value?: string;
  originalValue?: string;
  lineNumber: number;
}

interface CorrectionResult {
  success: boolean;
  correction: Correction;
  error?: string;
  before?: Record<string, any>;
  after?: Record<string, any>;
}

interface ApplyResult {
  actor: string;
  timestamp: string;
  inputFile: string;
  totalCorrections: number;
  applied: number;
  failed: number;
  skipped: number;
  results: CorrectionResult[];
  dryRun: boolean;
}

// ============================================================
// CLI PARSING
// ============================================================

function parseArgs(): { 
  actor: string; 
  input: string; 
  execute: boolean; 
  verbose: boolean;
  outputDir: string;
} {
  const args = process.argv.slice(2);
  
  const getArg = (name: string, defaultValue: string = ''): string => {
    const arg = args.find((a) => a.startsWith(`--${name}=`));
    return arg ? arg.split('=')[1] : defaultValue;
  };
  
  const hasFlag = (name: string): boolean => args.includes(`--${name}`);

  const actor = getArg('actor', '');
  const input = getArg('input', '');
  
  if (!actor || !input) {
    printHelp();
    process.exit(1);
  }

  return {
    actor,
    input,
    execute: hasFlag('execute') && !hasFlag('dry-run'),
    verbose: hasFlag('verbose') || hasFlag('v'),
    outputDir: getArg('output', 'docs'),
  };
}

function printHelp(): void {
  console.log(`
${chalk.cyan.bold('APPLY ACTOR CORRECTIONS')}

${chalk.yellow('Usage:')}
  npx tsx scripts/apply-actor-corrections.ts --actor="Actor Name" --input="path/to/corrections.csv" [options]

${chalk.yellow('Options:')}
  --actor=NAME         ${chalk.gray('Required: Actor name for context')}
  --input=PATH         ${chalk.gray('Required: Path to corrections CSV/TSV file')}
  --execute            ${chalk.gray('Actually apply corrections (default is dry run)')}
  --dry-run            ${chalk.gray('Preview changes without applying (default)')}
  --output=DIR         ${chalk.gray('Output directory for diff report (default: docs)')}
  --verbose, -v        ${chalk.gray('Show detailed progress')}

${chalk.yellow('CSV Format:')}
  action,slug,field,value
  
${chalk.yellow('Supported Actions:')}
  update          Update a specific field
  re-attribute    Change the hero field (for ghost entries)
  delete          Delete a movie (for duplicates)
  add             Add a new movie
  clear           Clear/null a field

${chalk.yellow('Examples:')}
  # Preview corrections
  npx tsx scripts/apply-actor-corrections.ts --actor="Nani" --input="docs/nani-corrections.csv"
  
  # Apply corrections
  npx tsx scripts/apply-actor-corrections.ts --actor="Nani" --input="docs/nani-corrections.csv" --execute
  
  # Verbose output
  npx tsx scripts/apply-actor-corrections.ts --actor="Venkatesh" --input="docs/venkatesh-fixes.csv" --execute -v

${chalk.yellow('Field Names:')}
  hero, heroine, director, music_director, producer, cinematographer
  editor (crew.editor), writer (crew.writer), tmdb_id, genres
`);
}

// ============================================================
// CSV/TSV PARSING
// ============================================================

function parseCorrectionsFile(filePath: string): Correction[] {
  if (!fs.existsSync(filePath)) {
    throw new Error(`File not found: ${filePath}`);
  }
  
  const content = fs.readFileSync(filePath, 'utf-8');
  const lines = content.split('\n').filter(l => l.trim());
  
  if (lines.length < 2) {
    throw new Error('File must have a header row and at least one data row');
  }
  
  // Detect delimiter
  const headerLine = lines[0];
  const delimiter = headerLine.includes('\t') ? '\t' : ',';
  
  // Parse header
  const headers = headerLine.split(delimiter).map(h => h.trim().toLowerCase());
  
  // Required columns
  const actionIdx = headers.indexOf('action');
  const slugIdx = headers.indexOf('slug');
  const fieldIdx = headers.indexOf('field');
  const valueIdx = headers.indexOf('value');
  
  if (actionIdx === -1 || slugIdx === -1) {
    throw new Error('CSV must have "action" and "slug" columns');
  }
  
  const corrections: Correction[] = [];
  
  for (let i = 1; i < lines.length; i++) {
    const line = lines[i].trim();
    if (!line || line.startsWith('#')) continue; // Skip empty lines and comments
    
    // Handle quoted CSV values
    const values = parseCSVLine(line, delimiter);
    
    const action = values[actionIdx]?.toLowerCase().trim() as CorrectionAction;
    const slug = values[slugIdx]?.trim();
    const field = fieldIdx !== -1 ? values[fieldIdx]?.trim() : undefined;
    const value = valueIdx !== -1 ? values[valueIdx]?.trim() : undefined;
    
    if (!action || !slug) {
      console.log(chalk.yellow(`  âš ï¸  Skipping line ${i + 1}: missing action or slug`));
      continue;
    }
    
    if (!['update', 're-attribute', 'delete', 'add', 'clear'].includes(action)) {
      console.log(chalk.yellow(`  âš ï¸  Skipping line ${i + 1}: invalid action "${action}"`));
      continue;
    }
    
    corrections.push({
      action,
      slug,
      field: field || undefined,
      value: value || undefined,
      lineNumber: i + 1,
    });
  }
  
  return corrections;
}

function parseCSVLine(line: string, delimiter: string): string[] {
  const values: string[] = [];
  let current = '';
  let inQuotes = false;
  
  for (let i = 0; i < line.length; i++) {
    const char = line[i];
    
    if (char === '"') {
      if (inQuotes && line[i + 1] === '"') {
        current += '"';
        i++;
      } else {
        inQuotes = !inQuotes;
      }
    } else if (char === delimiter && !inQuotes) {
      values.push(current);
      current = '';
    } else {
      current += char;
    }
  }
  values.push(current);
  
  return values.map(v => v.replace(/^"|"$/g, '').trim());
}

// ============================================================
// CORRECTION APPLICATION
// ============================================================

async function applyCorrection(
  correction: Correction,
  supabase: SupabaseClient,
  execute: boolean,
  verbose: boolean
): Promise<CorrectionResult> {
  const result: CorrectionResult = {
    success: false,
    correction,
  };
  
  try {
    switch (correction.action) {
      case 'update':
      case 're-attribute': {
        if (!correction.field || correction.value === undefined) {
          result.error = 'update/re-attribute requires field and value';
          return result;
        }
        
        // Get current value
        const { data: movie, error: fetchError } = await supabase
          .from('movies')
          .select('*')
          .eq('slug', correction.slug)
          .single();
        
        if (fetchError || !movie) {
          result.error = `Movie not found: ${correction.slug}`;
          return result;
        }
        
        result.before = { [correction.field]: getFieldValue(movie, correction.field) };
        result.after = { [correction.field]: correction.value };
        
        if (execute) {
          const updateData = buildUpdateData(correction.field, correction.value, movie);
          
          const { error: updateError } = await supabase
            .from('movies')
            .update(updateData)
            .eq('slug', correction.slug);
          
          if (updateError) {
            result.error = updateError.message;
            return result;
          }
        }
        
        result.success = true;
        if (verbose) {
          console.log(chalk.green(`  âœ“ ${correction.action}: ${correction.slug}.${correction.field} = "${correction.value}"`));
        }
        break;
      }
      
      case 'delete': {
        // Get movie info for logging
        const { data: movie } = await supabase
          .from('movies')
          .select('title_en, release_year')
          .eq('slug', correction.slug)
          .single();
        
        if (!movie) {
          result.error = `Movie not found: ${correction.slug}`;
          return result;
        }
        
        result.before = { movie };
        result.after = { deleted: true };
        
        if (execute) {
          const { error: deleteError } = await supabase
            .from('movies')
            .delete()
            .eq('slug', correction.slug);
          
          if (deleteError) {
            result.error = deleteError.message;
            return result;
          }
        }
        
        result.success = true;
        if (verbose) {
          console.log(chalk.red(`  âœ— delete: ${correction.slug} (${movie.title_en} ${movie.release_year})`));
        }
        break;
      }
      
      case 'clear': {
        if (!correction.field) {
          result.error = 'clear requires field';
          return result;
        }
        
        const { data: movie, error: fetchError } = await supabase
          .from('movies')
          .select('*')
          .eq('slug', correction.slug)
          .single();
        
        if (fetchError || !movie) {
          result.error = `Movie not found: ${correction.slug}`;
          return result;
        }
        
        result.before = { [correction.field]: getFieldValue(movie, correction.field) };
        result.after = { [correction.field]: null };
        
        if (execute) {
          const updateData = buildUpdateData(correction.field, null, movie);
          
          const { error: updateError } = await supabase
            .from('movies')
            .update(updateData)
            .eq('slug', correction.slug);
          
          if (updateError) {
            result.error = updateError.message;
            return result;
          }
        }
        
        result.success = true;
        if (verbose) {
          console.log(chalk.yellow(`  â—‹ clear: ${correction.slug}.${correction.field}`));
        }
        break;
      }
      
      case 'add': {
        // Adding new movies is complex - for now, just report
        result.error = 'Add action not yet implemented. Use database directly.';
        return result;
      }
    }
  } catch (err) {
    result.error = err instanceof Error ? err.message : 'Unknown error';
  }
  
  return result;
}

function getFieldValue(movie: any, field: string): any {
  // Handle nested crew fields
  if (['editor', 'writer'].includes(field)) {
    return movie.crew?.[field] || null;
  }
  return movie[field];
}

function buildUpdateData(field: string, value: string | null, movie: any): Record<string, any> {
  // Handle nested crew fields
  if (['editor', 'writer'].includes(field)) {
    const crew = { ...(movie.crew || {}) };
    crew[field] = value;
    return { crew };
  }
  
  // Handle special field transformations
  if (field === 'tmdb_id' && value) {
    return { tmdb_id: parseInt(value) };
  }
  
  if (field === 'genres' && value) {
    // Assume genres are semicolon or comma separated
    return { genres: value.split(/[;,]/).map(g => g.trim()).filter(Boolean) };
  }
  
  return { [field]: value };
}

// ============================================================
// DIFF REPORT GENERATION
// ============================================================

function generateDiffReport(result: ApplyResult, outputPath: string): void {
  const lines: string[] = [];
  
  lines.push(`# ${result.actor} Correction Report`);
  lines.push(`Generated: ${result.timestamp}`);
  lines.push(`Input: ${result.inputFile}`);
  lines.push(`Mode: ${result.dryRun ? 'DRY RUN' : 'EXECUTED'}`);
  lines.push('');
  lines.push(`## Summary`);
  lines.push(`- Total corrections: ${result.totalCorrections}`);
  lines.push(`- Applied: ${result.applied}`);
  lines.push(`- Failed: ${result.failed}`);
  lines.push(`- Skipped: ${result.skipped}`);
  lines.push('');
  
  if (result.results.filter(r => r.success).length > 0) {
    lines.push(`## Applied Changes`);
    lines.push('');
    lines.push('| # | Action | Slug | Field | Before | After |');
    lines.push('|---|--------|------|-------|--------|-------|');
    
    result.results
      .filter(r => r.success)
      .forEach((r, i) => {
        const before = r.before ? JSON.stringify(Object.values(r.before)[0]) : '-';
        const after = r.after ? JSON.stringify(Object.values(r.after)[0]) : '-';
        lines.push(`| ${i + 1} | ${r.correction.action} | ${r.correction.slug} | ${r.correction.field || '-'} | ${before} | ${after} |`);
      });
    lines.push('');
  }
  
  if (result.results.filter(r => !r.success).length > 0) {
    lines.push(`## Failed Changes`);
    lines.push('');
    lines.push('| # | Action | Slug | Error |');
    lines.push('|---|--------|------|-------|');
    
    result.results
      .filter(r => !r.success)
      .forEach((r, i) => {
        lines.push(`| ${i + 1} | ${r.correction.action} | ${r.correction.slug} | ${r.error || 'Unknown'} |`);
      });
    lines.push('');
  }
  
  fs.writeFileSync(`${outputPath}.md`, lines.join('\n'));
  fs.writeFileSync(`${outputPath}.json`, JSON.stringify(result, null, 2));
}

// ============================================================
// MAIN
// ============================================================

async function main(): Promise<void> {
  const { actor, input, execute, verbose, outputDir } = parseArgs();

  console.log(chalk.cyan.bold(`
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘           APPLY ACTOR CORRECTIONS                                    â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
`));

  console.log(`  Actor: ${chalk.yellow(actor)}`);
  console.log(`  Input: ${chalk.gray(input)}`);
  console.log(`  Mode: ${execute ? chalk.green('EXECUTE') : chalk.yellow('DRY RUN')}`);

  const supabase = createClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.SUPABASE_SERVICE_ROLE_KEY!
  );

  try {
    // Parse corrections file
    console.log(chalk.cyan('\n  ğŸ“‚ Parsing corrections file...'));
    const corrections = parseCorrectionsFile(input);
    console.log(chalk.green(`     Found ${corrections.length} corrections`));
    
    // Group by action for summary
    const byAction: Record<string, number> = {};
    for (const c of corrections) {
      byAction[c.action] = (byAction[c.action] || 0) + 1;
    }
    console.log(chalk.gray(`     ${Object.entries(byAction).map(([a, c]) => `${a}: ${c}`).join(', ')}`));

    // Apply corrections
    console.log(chalk.cyan(`\n  ${execute ? 'ğŸ”§ Applying' : 'ğŸ‘€ Previewing'} corrections...`));
    
    const results: CorrectionResult[] = [];
    let applied = 0;
    let failed = 0;
    let skipped = 0;
    
    for (const correction of corrections) {
      const result = await applyCorrection(correction, supabase, execute, verbose);
      results.push(result);
      
      if (result.success) {
        applied++;
      } else if (result.error) {
        failed++;
        if (!verbose) {
          console.log(chalk.red(`  âœ— Line ${correction.lineNumber}: ${result.error}`));
        }
      } else {
        skipped++;
      }
    }

    // Generate result
    const applyResult: ApplyResult = {
      actor,
      timestamp: new Date().toISOString(),
      inputFile: input,
      totalCorrections: corrections.length,
      applied,
      failed,
      skipped,
      results,
      dryRun: !execute,
    };

    // Ensure output directory exists
    if (!fs.existsSync(outputDir)) {
      fs.mkdirSync(outputDir, { recursive: true });
    }

    // Generate diff report
    const actorSlug = actor.toLowerCase().replace(/\s+/g, '-');
    const reportPath = `${outputDir}/${actorSlug}-correction-report`;
    generateDiffReport(applyResult, reportPath);

    // Print summary
    console.log(chalk.cyan.bold(`
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
ğŸ“Š CORRECTION SUMMARY
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
`));

    console.log(`  Total corrections: ${chalk.yellow(corrections.length)}`);
    console.log(`  Applied: ${chalk.green(applied)}`);
    console.log(`  Failed: ${chalk.red(failed)}`);
    console.log(`  Skipped: ${chalk.gray(skipped)}`);
    
    console.log(chalk.cyan(`\n  ğŸ“„ Reports saved:`));
    console.log(chalk.gray(`     ${reportPath}.md`));
    console.log(chalk.gray(`     ${reportPath}.json`));

    if (!execute) {
      console.log(chalk.yellow(`\n  ğŸ’¡ Run with --execute to apply these ${applied} corrections`));
    }

  } catch (error) {
    console.error(chalk.red('\n  âŒ Correction failed:'), error);
    process.exit(1);
  }
}

// Run if main module
if (require.main === module) {
  main().catch(console.error);
}

// Export for programmatic use
export {
  parseCorrectionsFile,
  applyCorrection,
  generateDiffReport,
  type Correction,
  type CorrectionResult,
  type ApplyResult,
};
